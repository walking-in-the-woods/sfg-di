
                What is Docker?

    - Docker is a standard for Linux containers.
    - A "Container" is an isolated runtime inside of Linux
    - A "Container" provides a private machine like space under Linux
    - Containers will run under any modern Linux Kernel

                Containers can:

    - Have their own process space
    - Their own network interface
    - "Run" processes as root (inside the container)
    - Have their own disk space
    - (can share with host too)

                A Container is not a VM!

            Virtual Machine                                 Containers

        App1        App2        App3
    Bins/Libs   Bins/Libs   Bins/Libs               App1        App2        App3
    Guest OS    Guest OS    Guest OS              Bins/Libs   Bins/Libs   Bins/Libs
    ---------- Hypervisor -----------             --------- Docker Engine ---------
    ----- Host Operating System -----             -------- Operating System -------
    --------- Infrastructure --------             --------- Infrastructure --------

    The main difference that containers have no guest operating systems.

                Docker Terminology

    - Docker Image - The representation of a Docker Container. Kind of like a JAR or WAR file in Java
    - Docker Container - The standard runtime of Docker. Effectively a deployed and running Docker Image.
                         Like a Spring Boot Executable JAR
    - Docker Engine - The code which manages Docker stuff. Creates and runs Docker Containers

                Docker Engine Runtime

    network     container       image       data volumes
       |____________|_____________|______________|
                           |
                    Client docker CLI
                           |
                        REST API
                           |
                  server docker daemon


                Docker Editions

    Docker Enterprise Edition vs Docker Community Edition

                Docker Enterprise Edition

    - CaaS (Container as a Service) platform subscription
    - Enterprise class support
    - Quarterly Releases
    - Backported patches for 1 yr
    - Certified Infrastructure

                Docker Community Edition

    - Free Docker edition for developers and operations
    - Monthly "edge" release with latest features for developers
    - Quarterly releases for operations

                Start a Mongo Instance

    $ docker run --name some-mongo -d mongo

    --name
    -d - tells it to run in the background
    mongo - the last image
    mongo:tag

    ... where some-mongo is the name you want to assign to your container
    and tag is the tag specifying the MongoDB version you want

    docker pull mongo
    sudo docker run -d mongo
    sudo docker ps
    sudo docker stop 67c33933139e
    sudo docker run -p 27017:27017 -d mongo     // now this is mapped to the port 27017

                Docker Image

    - An Image defines a Docker Container
        - Similar in concept to a snapshot of a VM
        - Or a class vs an instance of the class
    - Images are immutable
        - Once built, the files making up an image do not change.

                Image Layers

    - Images are built in layers
    - Each layer is an immutable file, but is a collection of files and directories
    - Layers receive an ID, calculated via a SHA 256 hash of the layer contents.
        - Thus, if the layer contents change, the SHA 256 hash changes also.

                Image Ids

    - Image Ids are a SHA 256 hash derived from the layers
        - Thus if the layers of the image changes, the SHA 256 hash changes
    - The image ID listed by docker commands (ie "docker images") is the first 12 characters of the hash

                Image Tag Names

    - The hash values of images are referred to by "tag" names.
    - The format of the full tag name is: [REGISTRYHOST/][USERNAME/]NAME[:TAG]
    - For Registry Host "registry.hub.docker.com" is inferred
    - For ":TAG" - "latest" is default, and inferred
    - Full tag example: registry.hub.docker.com/mongo:latest

FROM ubuntu:xenial

# add our user and group first to make sure their IDs get assigned consistently, regardless of whatever dependencies get added
RUN groupadd -r mongodb && useradd -r -g mongodb mongodb

RUN set -eux; \
	apt-get update; \
	apt-get install -y --no-install-recommends \
		ca-certificates \
		jq \
		numactl \
	; \
	if ! command -v ps > /dev/null; then \
		apt-get install -y --no-install-recommends procps; \
	fi; \
	rm -rf /var/lib/apt/lists/*

******************************** Docker file example ***********************************

FROM ubuntu:xenial

# add our user and group first to make sure their IDs get assigned consistently, regardless of whatever dependencies get added
RUN groupadd -r mongodb && useradd -r -g mongodb mongodb

RUN set -eux; \
	apt-get update; \
	apt-get install -y --no-install-recommends \
		ca-certificates \
		jq \
		numactl \
	; \
	if ! command -v ps > /dev/null; then \
		apt-get install -y --no-install-recommends procps; \
	fi; \
	rm -rf /var/lib/apt/lists/*

# grab gosu for easy step-down from root (https://github.com/tianon/gosu/releases)
ENV GOSU_VERSION 1.12
# grab "js-yaml" for parsing mongod's YAML config files (https://github.com/nodeca/js-yaml/releases)
ENV JSYAML_VERSION 3.13.1

RUN set -ex; \
	\
	savedAptMark="$(apt-mark showmanual)"; \
	apt-get update; \
	apt-get install -y --no-install-recommends \
		wget \
	; \
	if ! command -v gpg > /dev/null; then \
		apt-get install -y --no-install-recommends gnupg dirmngr; \
		savedAptMark="$savedAptMark gnupg dirmngr"; \
	elif gpg --version | grep -q '^gpg (GnuPG) 1\.'; then \
# "This package provides support for HKPS keyservers." (GnuPG 1.x only)
		apt-get install -y --no-install-recommends gnupg-curl; \
	fi; \
	rm -rf /var/lib/apt/lists/*; \
	\
	dpkgArch="$(dpkg --print-architecture | awk -F- '{ print $NF }')"; \
	wget -O /usr/local/bin/gosu "https://github.com/tianon/gosu/releases/download/$GOSU_VERSION/gosu-$dpkgArch"; \
	wget -O /usr/local/bin/gosu.asc "https://github.com/tianon/gosu/releases/download/$GOSU_VERSION/gosu-$dpkgArch.asc"; \
	export GNUPGHOME="$(mktemp -d)"; \
	gpg --batch --keyserver hkps://keys.openpgp.org --recv-keys B42F6819007F00F88E364FD4036A9C25BF357DD4; \
	gpg --batch --verify /usr/local/bin/gosu.asc /usr/local/bin/gosu; \
	command -v gpgconf && gpgconf --kill all || :; \
	rm -r "$GNUPGHOME" /usr/local/bin/gosu.asc; \
	\
	wget -O /js-yaml.js "https://github.com/nodeca/js-yaml/raw/${JSYAML_VERSION}/dist/js-yaml.js"; \
# TODO some sort of download verification here
	\
	apt-mark auto '.*' > /dev/null; \
	apt-mark manual $savedAptMark > /dev/null; \
	apt-get purge -y --auto-remove -o APT::AutoRemove::RecommendsImportant=false; \
	\
# smoke test
	chmod +x /usr/local/bin/gosu; \
	gosu --version; \
	gosu nobody true

RUN mkdir /docker-entrypoint-initdb.d

ENV GPG_KEYS 2930ADAE8CAF5059EE73BB4B58712A2291FA4AD5
RUN set -ex; \
	export GNUPGHOME="$(mktemp -d)"; \
	for key in $GPG_KEYS; do \
		gpg --batch --keyserver ha.pool.sks-keyservers.net --recv-keys "$key"; \
	done; \
	gpg --batch --export $GPG_KEYS > /etc/apt/trusted.gpg.d/mongodb.gpg; \
	command -v gpgconf && gpgconf --kill all || :; \
	rm -r "$GNUPGHOME"; \
	apt-key list

# Allow build-time overrides (eg. to build image with MongoDB Enterprise version)
# Options for MONGO_PACKAGE: mongodb-org OR mongodb-enterprise
# Options for MONGO_REPO: repo.mongodb.org OR repo.mongodb.com
# Example: docker build --build-arg MONGO_PACKAGE=mongodb-enterprise --build-arg MONGO_REPO=repo.mongodb.com .
ARG MONGO_PACKAGE=mongodb-org
ARG MONGO_REPO=repo.mongodb.org
ENV MONGO_PACKAGE=${MONGO_PACKAGE} MONGO_REPO=${MONGO_REPO}

ENV MONGO_MAJOR 3.6
ENV MONGO_VERSION 3.6.23
# bashbrew-architectures:amd64 arm64v8
RUN echo "deb http://$MONGO_REPO/apt/ubuntu xenial/${MONGO_PACKAGE%-unstable}/$MONGO_MAJOR multiverse" | tee "/etc/apt/sources.list.d/${MONGO_PACKAGE%-unstable}.list"

RUN set -x \
# installing "mongodb-enterprise" pulls in "tzdata" which prompts for input
	&& export DEBIAN_FRONTEND=noninteractive \
	&& apt-get update \
# starting with MongoDB 4.3 (and backported to 4.0 and 4.2 *and* 3.6??), the postinst for server includes an unconditional "systemctl daemon-reload" (and we don't have anything for "systemctl" to talk to leading to dbus errors and failed package installs)
	&& ln -s /bin/true /usr/local/bin/systemctl \
	&& apt-get install -y \
		${MONGO_PACKAGE}=$MONGO_VERSION \
		${MONGO_PACKAGE}-server=$MONGO_VERSION \
		${MONGO_PACKAGE}-shell=$MONGO_VERSION \
		${MONGO_PACKAGE}-mongos=$MONGO_VERSION \
		${MONGO_PACKAGE}-tools=$MONGO_VERSION \
	&& rm -f /usr/local/bin/systemctl \
	&& rm -rf /var/lib/apt/lists/* \
	&& rm -rf /var/lib/mongodb \
	&& mv /etc/mongod.conf /etc/mongod.conf.orig

RUN mkdir -p /data/db /data/configdb \
	&& chown -R mongodb:mongodb /data/db /data/configdb
VOLUME /data/db /data/configdb

COPY docker-entrypoint.sh /usr/local/bin/
ENTRYPOINT ["docker-entrypoint.sh"]

EXPOSE 27017
CMD ["mongod"]

******************************** Docker file example ***********************************

FROM ubuntu:xenial      // We get the particular docker image (we actually inherit from it)
RUN groupadd -r mongodb && useradd -r -g mongodb mongodb    // We add a user

RUN set -eux; \                                             // Each group of commands divided by "/"
	apt-get update; \                                       // is going to create an image layer
	apt-get install -y --no-install-recommends \
		ca-certificates \
		jq \
		numactl \
	; \
	if ! command -v ps > /dev/null; then \
		apt-get install -y --no-install-recommends procps; \
	fi; \
	rm -rf /var/lib/apt/lists/*

***** If we look at Ubuntu docker file, we get it from scratch, from the tar.gz archive

FROM scratch
ADD ubuntu-focal-core-cloudimg-amd64-root.tar.gz /

***** So, the key thing is that docker images can INHERIT from each other

        Mongo        Ubuntu     // image
          |            |
        *****          |        // layer
        *****          |
        ***** <----> *****      // layer (these are shared)
        ***** <----> *****
        ***** <----> *****

        To persist data in the file system:

    1.  Create a data directory on a suitable volume on your host system, e.g. /my/own/datadir.

    2.  Start your mongo container like this:

    $ docker run --name some-mongo -v /my/own/datadir:/data/db -d mongo

    The -v /my/own/datadir:/data/db part of the command mounts the /my/own/datadir directory from the
    underlying host system as /data/db inside the container, where MongoDB by default will write its data files.

    This image also defines a volume for /data/configdb for use with --configsvr

            TO PERSIST DATA IN WINDOWS 10 LOCAL DRIVE:

    1.  start Ubuntu on WSL-2   // don't forget to add the WSL-2 support in Windows and Docker
    2.  cd /mnt/d/code/db/mongo // move to the empty directory where we're going to create a db wired to the container
    3.  sudo docker run -p 27017:27017 -v /pwd/:/data/db -d mongo // run docker command in the current directory
    4.  sudo docker ps  // to see that the container is wired
    5.  run the app and test the persistence in a browser (create an item in the db)
    6.  sudo docker stop <..container hash from ps command result..>
    7.  history | grep mongo    // get all the commands with "mongo" (or whatever db you're wiring)
    8.  56  sudo docker run -p 27017:27017 -v /pwd/:/data/db -d mongo   // find the command with which we created the db
    9.  !56 //  this command repeats the chosen one (#56 in this example)
    10. sudo docker ps  // to see that the container is wired
    11. run the app to check the persistence in a browser (we should see the item we created in step 5)
    ....
    #   PROFIT